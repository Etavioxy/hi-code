struct dt{ int mx,p; };
dt NIL = (dt){(int)-1e9,-1};
dt operator+(const dt&a,const dt&b){
	return a.mx>b.mx ? a:b ;
}
class LCT{
private:
	struct node{
		node*fa,*c[2];
		dt x,x0;
		bool rev;
		#define lch c[0]
		#define rch c[1]
		void update(){
			x = lch->x + x0 + rch->x;
		}
		void downdate(){
			if( rev ){
				lch->rev^=1, rch->rev^=1;
				swap(lch,rch), rev=0;
			}
		}
	}d[N];
	bool chk(node*e){ return e->fa->rch==e; }
	bool nroot(node*e){
		return e->fa!=d&&(e->fa->lch==e||e->fa->rch==e);
	}
	node*get(node*x,bool o,node*y){
		return x->c[o]=y, y->fa=x;
	}
	void rotate(node*e){
		bool o = chk(e), ox= chk(e->fa);
		node*x = e->fa, *y = x->fa, *w = e->c[o^1];
		( nroot(x) ? y->c[ox]=e:0 ), e->c[o^1]=x, x->c[o]=w;
		( w!=d ? w->fa=x:0 ), x->fa=e, e->fa=y;
		x->update(), e->update();
	}
	void Downdate(node*e){
		if( nroot(e) ) Downdate(e->fa);
		e->downdate();
	}
	node*splay(node*e){
		Downdate(e);
		while( nroot(e) ){
			node*x = e->fa;
			if( nroot(x) ) rotate(chk(e)^chk(x)?e:x);
			rotate(e);
		} return e;
	}
	node*access(node*x){
		node*y=d;
		for(;x!=d;y=x,x=x->fa){
			splay(x), get(x,1,y), x->update();
		} return y;
	}
	node*makeroot(node*e){
		access(e), splay(e), e->rev^=1;
		return e;
	}
	node*findroot(node*e){
		access(e), splay(e);
		while( 1 ){
			e->downdate();
			if( e->lch==d ) break;
			e = e->lch;
		} return splay(e);
	}
	void link(node*x,node*y){
		makeroot(x)->fa = y;
	}
	void cut(node*x,node*y){
		makeroot(x), access(y), splay(y), y->lch=x->fa=d, x->update();
	}
	node*split(node*x,node*y){
		makeroot(x), access(y); return splay(y);
	}
public:
	void init(int n){
		*d = (node){d,d,d,NIL,NIL};
		rep(i,1,n) d[i] = (node){d,d,d,NIL,NIL};
	}
	bool chk(int x,int y){
		return findroot(d+x)==findroot(d+y);
	}
	int recx[N],recy[N];
	void add(dt t,int x,int y){
		recx[t.p]=x, recy[t.p]=y;
		node*e = d+t.p;
		*e = (node){d,d,d,t,t};
		link(e,d+x), link(e,d+y);
	}
	void del(int id){
		int x=recx[id], y=recy[id];
		cut(d+id,d+x);
		cut(d+id,d+y);
	}
	dt query(int x,int y){
		return split(d+x,d+y)->x;
	}
};
