struct Edge{ int nxt,to; ll cap; } bow[M*2];
int head[N],tot_e,tot_v,s,t;
void add(int x,int y,ll z){
	tot_e++;
	bow[tot_e<<1] = (Edge){head[x],y,z};
	bow[tot_e<<1|1] = (Edge){head[y],x,0};
	head[y] = (head[x]=tot_e<<1)|1;
}
int depth[N],cur[N];
bool BFS(){
	memcpy(cur,head,sizeof(int)*(tot_v+1));
	memset(depth,0,sizeof(int)*(tot_v+1));
	queue <int> q;
	depth[s] = 1;
	q.push(s);
	while( q.empty()==0 ){
		int u = q.front();
		q.pop();
		each(i,u) if( bow[i].cap ){
			int v = bow[i].to;
			if( depth[v]==0 ) depth[v]=depth[u]+1, q.push(v);
		}
	}
	return (bool)depth[t];
}
ll DFS(int u,ll now){
	if( u==t || now==0 ) return now;
	ll flow = 0;
	for(int&i=cur[u];i;i=bow[i].nxt){
		int v = bow[i].to;
		if( depth[v]!=depth[u]+1 ) continue;
		ll f = DFS(v,min(now,bow[i].cap));
		now  -= f;
		flow += f;
		bow[i].cap   -= f;
		bow[i^1].cap += f;
	} return flow;
}
