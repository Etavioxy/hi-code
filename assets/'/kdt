struct dt{ ll sum; dt(){} dt(ll x):sum(x){} };
dt NIL = 0;
dt operator+(const dt&a,const dt&b){
	return a.sum+b.sum;
}
struct Key{ int x,y; Key(){} Key(int xx,int yy):x(xx),y(yy){} };
class KDT{
private:
	struct node{
		node*c[2];
		dt x,x0;
		Key key; int opt;
		#define lch c[0]
		#define rch c[1]
		void update(){
			x = lch->x + x0 + rch->x;
		}
	}d[N];
	struct cmp0{ bool operator()(node*L,node*R){ return L->key.x<R->key.x; } };
	struct cmp1{ bool operator()(node*L,node*R){ return L->key.y<R->key.y; } };
	node*a[N];
	node*build(int opt,int l,int r){
		if( l>r ) return d;
		int mid = (l+r)/2;
		if( opt==0 ) nth_element(a+l,a+mid,a+r+1,cmp0());
		if( opt==1 ) nth_element(a+l,a+mid,a+r+1,cmp1());
		node*e = a[mid];
		e->opt = opt;
		e->lch = build(opt^1,l,mid-1);
		e->rch = build(opt^1,mid+1,r);
		e->update();
		return e;
	}
	ll A,B,C;
	int chk(Key x){
		return x.x*A + x.y*B < C;
	}
	dt query(node*e,Key L,Key R){
		if( e==d ) return NIL;
		int tot = chk(L)+chk(R)+chk(Key(L.x,R.y))+chk(Key(R.x,L.y));
		if( tot==4 ) return e->x;
		if( tot==0 ) return NIL;
		return ( chk(e->key) ? e->x0 : NIL )
			+query(e->lch,L,e->opt?Key(R.x,e->key.y):Key(e->key.x,R.y))
			+query(e->rch,  e->opt?Key(L.x,e->key.y):Key(e->key.x,L.y),R);
	}
	node*&Root(){ return d->lch; }
	int n;
	Key sL,sR;
public:
	KDT(){
		*d = (node){d,d,NIL,NIL};
		sL = Key(1e9,1e9), sR = Key(-1e9,-1e9);
	}
	void push(Key x,dt y){
		d[++n]=(node){d,d,y,y,x};
		sL = Key(min(sL.x,x.x),min(sL.y,x.y));
		sR = Key(max(sR.x,x.x),max(sR.y,x.y));
	}
	int solve(){
		rep(i,1,n) a[i] = d+i;
		Root() = build(0,1,n);
		return n;
	}
	dt query(ll A0,ll B0,ll C0){
		A=A0, B=B0, C=C0;
		return query(Root(),sL,sR);
	}
};
