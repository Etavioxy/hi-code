struct data{ int mx; data(){} data(int x):mx(x){} };
data NIL = (int)-1e9;
data operator+(const data&a,const data&b){
	return max(a.mx,b.mx);
}
class SEG{
private:
	struct node{
		node*c[2];
		data x;
		#define lch c[0]
		#define rch c[1]
		void update(){
			x = lch->x + rch->x;
		}
	}d[N*50];
	int tot_d;
	void add(node*&e,int l,int r,int ql,int qr,data x){
		if( e==d ) e = &(d[++tot_d]=*d);
		if( ql<=l && r<=qr ) return e->x = e->x+x, void();
		int mid = (l+r)/2;
		( ql<=mid ? add(e->lch, l,mid ,ql,qr,x) : void());
		( mid< qr ? add(e->rch,mid+1,r,ql,qr,x) : void());
		e->update();
	}
	data query(node*e,int l,int r,int ql,int qr){
		if( e==d ) return NIL;
		if( ql<=l && r<=qr ) return e->x;
		int mid = (l+r)/2;
		return ( ql<=mid ? query(e->lch, l,mid ,ql,qr) : NIL)
			  +( mid< qr ? query(e->rch,mid+1,r,ql,qr) : NIL);
	}
	void merge(node*&x,node*y,int l,int r){
		if( y==d ) return ;
		if( x==d ) return x=y, void();
		if( l==r ) return x->x=x->x+y->x, void();
//		x = &(d[++tot_d]=*x);
		int mid = (l+r)/2;
		merge(x->lch,y->lch, l,mid );
		merge(x->rch,y->rch,mid+1,r);
		x->update();
	}
	int find(node*e,int l,int r,int k){
		if( l==r ) return l;
		int mid = (l+r)/2;
		data L = e->lch->x;
		return k <= L.mx ?
			find(e->lch, l,mid ,k):
			find(e->rch,mid+1,r,k);
	}
	node*ver[N];
	int n;
public:
	void init(int tot_ver,int n0){
		*d = (node){d,d,NIL};
		n = n0;
		fill(ver,ver+tot_ver+1,(node*)d);
	}
	void add(int x,int p,data y){
		add(ver[x],1,n,p,p,y);
	}
	data query(int x,int l,int r){
		return query(ver[x],1,n,l,r);
	}
	void merge(int x,int y){
		merge(ver[x],ver[y],1,n);
	}
	int find(int x,int k){
		if( ver[x]->x.mx < k ) return 0;
		return find(ver[x],1,n,k);
	}
};
