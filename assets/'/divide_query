int ans[N];
struct sth{
	int opt,x1,x2,x3,id;
};
sth d[N];
void solve(int ql,int qr,int ansl,int ansr){
	static sth L[N],R[N];
	if( ql > qr ) return ;
	if( ansl==ansr ){
		rep(i,ql,qr) if( d[i].opt==2 ) ans[d[i].id] = ansl;
		return ;
	}
	int mid = (ansl+ansr)/2;
	int tot_L = 0, tot_R = 0;
	rep(i,ql,qr){
		if( d[i].opt==1 ){
			int p=d[i].x1, f=d[i].x2, x=d[i].x3;
			if( x <= mid ) L[++tot_L] = d[i], bit.add(p,f);
			else R[++tot_R]= d[i];
		}else{
			int l=d[i].x1, r=d[i].x2, &k=d[i].x3;
			int lsum = bit.query(r) - bit.query(l-1);
			if( k <= lsum ) L[++tot_L] = d[i];
			else k -= lsum, R[++tot_R] = d[i];
		}
	}
	bit.clear();
	int qm = ql+tot_L;
	memcpy(d+ql,L+1,sizeof(sth)*tot_L);
	memcpy(d+qm,R+1,sizeof(sth)*tot_R);
	solve(ql,qm-1,ansl,mid);
	solve(qm,qr,mid+1,ansr);
}
